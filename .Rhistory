accept[i] <- 1
}
else {
accept[i]<-0
oldlik<-lik
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)*100))
}
MCMC(c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000),c(C1=125, C20=134, C21=21),10000,1,3,100)
library(extraDistr)
MCMC <- function(theta.0, y, n.iter, a, b, k){
c1 <- y[1]
c20 <- y[2]
c21 <- y[3]
c2 <- c20 + c21
pi.0 <- theta.0[1]
N.0 <- theta.0[2]
chain <- matrix(0, nrow=n.iter, ncol=2, dimnames=list(NULL,c("pi","N")))
accept <- vector("numeric", n.iter)
chain[1, 1:2] <- theta.0
accept[1] <- 1
N.curr <- N.0
pi.curr <- pi.0
oldlik <- N.law(N.curr, pi.curr, c1, c20)
for (i in 2:n.iter){
#on tire dans la loi conditionnelle complète de pi
#loi uniforme discrète
N.cand <- rdunif(1,N.curr-k,N.curr+k)
u <- runif(n=1,min=0,max=1)
print(pi.curr)
pi.curr <- rbeta(n=1, shape1=c1+c2+a, shape2=2*N.curr-c1-c2+b)
print(pi.curr)
lik <- N.law(N.cand, pi.curr, c1, c20)
r <- lik/oldlik
if (u<min(c(1,r),na.rm=TRUE))
{
N.curr <- N.cand
oldlik <- lik
accept[i] <- 1
}
else {
accept[i]<-0
oldlik<-lik
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)*100))
}
MCMC(c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000),c(C1=125, C20=134, C21=21),10000,1,3,100)
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
rbeta(n=1, shape1=125+134+21+1, shape2=2*1000-125-134-21+3)
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
rbeta(n=1, shape1=125+134+21+1, shape2=2*950-125-134-21+3)
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
rbeta(n=1, shape1=125+134+21+1, shape2=2*750-125-134-21+3)
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
rbeta(n=1, shape1=125+134+21+1, shape2=2*1200-125-134-21+3)
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
rbeta(n=1, shape1=125+134+21+1, shape2=2*1500-125-134-21+3)
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
rbeta(n=1, shape1=125+134+21+1, shape2=2*2000-125-134-21+3)
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
rbeta(n=1, shape1=125+134+21+1, shape2=2*400-125-134-21+3)
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
rbeta(n=1, shape1=125+134+21+1, shape2=2*1500-125-134-21+3)
library(extraDistr)
MCMC <- function(theta.0, y, n.iter, a, b, k){
c1 <- y[1]
c20 <- y[2]
c21 <- y[3]
c2 <- c20 + c21
pi.0 <- theta.0[1]
N.0 <- theta.0[2]
chain <- matrix(0, nrow=n.iter, ncol=2, dimnames=list(NULL,c("pi","N")))
accept <- vector("numeric", n.iter)
chain[1, 1:2] <- theta.0
accept[1] <- 1
N.curr <- N.0
pi.curr <- pi.0
oldlik <- N.law(N.curr, pi.curr, c1, c20)
for (i in 2:n.iter){
#on tire dans la loi conditionnelle complète de pi
#loi uniforme discrète
N.cand <- rdunif(1,N.curr-k,N.curr+k)
u <- runif(n=1,min=0,max=1)
pi.curr <- rbeta(n=1, shape1=c1+c2+a, shape2=2*N.cand-c1-c2+b)
lik <- N.law(N.cand, pi.curr, c1, c20)
r <- lik/oldlik
if (u<min(c(1,r),na.rm=TRUE))
{
N.curr <- N.cand
oldlik <- lik
accept[i] <- 1
}
else {
accept[i]<-0
oldlik<-lik
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)*100))
}
MCMC(c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000),c(C1=125, C20=134, C21=21),10000,1,3,100)
library(extraDistr)
MCMC <- function(theta.0, y, n.iter, a, b, k){
c1 <- y[1]
c20 <- y[2]
c21 <- y[3]
c2 <- c20 + c21
pi.0 <- theta.0[1]
N.0 <- theta.0[2]
chain <- matrix(0, nrow=n.iter, ncol=2, dimnames=list(NULL,c("pi","N")))
accept <- vector("numeric", n.iter)
chain[1, 1:2] <- theta.0
accept[1] <- 1
N.curr <- N.0
pi.curr <- pi.0
oldlik <- N.law(N.curr, pi.curr, c1, c20)
for (i in 2:n.iter){
#on tire dans la loi conditionnelle complète de pi
#loi uniforme discrète
N.cand <- rdunif(1,N.curr-k,N.curr+k)
u <- runif(n=1,min=0,max=1)
pi.curr <- rbeta(n=1, shape1=c1+c2+a, shape2=2*N.cand-c1-c2+b)
lik <- N.law(N.cand, pi.curr, c1, c20)
r <- lik/oldlik
if (u<min(c(1,r)))
{
N.curr <- N.cand
oldlik <- lik
accept[i] <- 1
}
else {
accept[i]<-0
oldlik<-lik
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)*100))
}
MCMC(c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000),c(C1=125, C20=134, C21=21),10000,1,3,100)
library(extraDistr)
MCMC <- function(theta.0, y, n.iter, a, b, k){
c1 <- y[1]
c20 <- y[2]
c21 <- y[3]
c2 <- c20 + c21
pi.0 <- theta.0[1]
N.0 <- theta.0[2]
chain <- matrix(0, nrow=n.iter, ncol=2, dimnames=list(NULL,c("pi","N")))
accept <- vector("numeric", n.iter)
chain[1, 1:2] <- theta.0
accept[1] <- 1
N.curr <- N.0
pi.curr <- pi.0
oldlik <- N.law(N.curr, pi.curr, c1, c20)
for (i in 2:n.iter){
#on tire dans la loi conditionnelle complète de pi
#loi uniforme discrète
N.cand <- rdunif(1,N.curr-k,N.curr+k)
u <- runif(n=1,min=0,max=1)
pi.curr <- rbeta(n=1, shape1=c1+c2+a, shape2=2*N.curr-c1-c2+b)
lik <- N.law(N.cand, pi.curr, c1, c20)
r <- lik/oldlik
print(r)
if (u<min(c(1,r)))
{
N.curr <- N.cand
oldlik <- lik
accept[i] <- 1
}
else {
accept[i]<-0
oldlik<-lik
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)*100))
}
MCMC(c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000),c(C1=125, C20=134, C21=21),10000,1,3,100)
library(extraDistr)
MCMC <- function(theta.0, y, n.iter, a, b, k){
c1 <- y[1]
c20 <- y[2]
c21 <- y[3]
c2 <- c20 + c21
pi.0 <- theta.0[1]
N.0 <- theta.0[2]
chain <- matrix(0, nrow=n.iter, ncol=2, dimnames=list(NULL,c("pi","N")))
accept <- vector("numeric", n.iter)
chain[1, 1:2] <- theta.0
accept[1] <- 1
N.curr <- N.0
pi.curr <- pi.0
oldlik <- N.law(N.curr, pi.curr, c1, c20)
for (i in 2:n.iter){
#on tire dans la loi conditionnelle complète de pi
#loi uniforme discrète
N.cand <- rdunif(1,N.curr-k,N.curr+k)
u <- runif(n=1,min=0,max=1)
pi.curr <- rbeta(n=1, shape1=c1+c2+a, shape2=2*N.curr-c1-c2+b)
lik <- N.law(N.cand, pi.curr, c1, c20)
r <- lik/oldlik
print(r)
print(N.cand)
if (u<min(c(1,r)))
{
N.curr <- N.cand
oldlik <- lik
accept[i] <- 1
}
else {
accept[i]<-0
oldlik<-lik
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)*100))
}
MCMC(c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000),c(C1=125, C20=134, C21=21),10000,1,3,100)
library(extraDistr)
MCMC <- function(theta.0, y, n.iter, a, b, k){
c1 <- y[1]
c20 <- y[2]
c21 <- y[3]
c2 <- c20 + c21
pi.0 <- theta.0[1]
N.0 <- theta.0[2]
chain <- matrix(0, nrow=n.iter, ncol=2, dimnames=list(NULL,c("pi","N")))
accept <- vector("numeric", n.iter)
chain[1, 1:2] <- theta.0
accept[1] <- 1
N.curr <- N.0
pi.curr <- pi.0
oldlik <- N.law(N.curr, pi.curr, c1, c20)
for (i in 2:n.iter){
#on tire dans la loi conditionnelle complète de pi
#loi uniforme discrète
N.cand <- rdunif(1,N.curr-k,N.curr+k)
u <- runif(n=1,min=0,max=1)
pi.curr <- rbeta(n=1, shape1=c1+c2+a, shape2=2*N.curr-c1-c2+b)
lik <- N.law(N.cand, pi.curr, c1, c20)
r <- lik/oldlik
if (u<min(c(1,r)))
{
N.curr <- N.cand
oldlik <- lik
accept[i] <- 1
}
else {
accept[i]<-0
oldlik<-lik
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)*100))
}
MCMC(c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=900),c(C1=125, C20=134, C21=21),10000,1,3,30)
library(extraDistr)
MCMC <- function(theta.0, y, n.iter, a, b, k){
c1 <- y[1]
c20 <- y[2]
c21 <- y[3]
c2 <- c20 + c21
pi.0 <- theta.0[1]
N.0 <- theta.0[2]
chain <- matrix(0, nrow=n.iter, ncol=2, dimnames=list(NULL,c("pi","N")))
accept <- vector("numeric", n.iter)
chain[1, 1:2] <- theta.0
accept[1] <- 1
N.curr <- N.0
pi.curr <- pi.0
oldlik <- N.law(N.curr, pi.curr, c1, c20)
for (i in 2:n.iter){
#on tire dans la loi conditionnelle complète de pi
#loi uniforme discrète
N.cand <- rdunif(1,N.curr-k,N.curr+k)
u <- runif(n=1,min=0,max=1)
pi.curr <- rbeta(n=1, shape1=c1+c2+a, shape2=2*N.curr-c1-c2+b)
lik <- N.law(N.cand, pi.curr, c1, c20)
r <- lik/oldlik
if (u<min(c(1,r),na.rm = TRUE))
{
N.curr <- N.cand
oldlik <- lik
accept[i] <- 1
}
else {
accept[i]<-0
oldlik<-lik
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)*100))
}
MCMC(c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=900),c(C1=125, C20=134, C21=21),10000,1,3,30)
library(extraDistr)
MCMC <- function(theta.0, y, n.iter, a, b, k){
c1 <- y[1]
c20 <- y[2]
c21 <- y[3]
c2 <- c20 + c21
pi.0 <- theta.0[1]
N.0 <- theta.0[2]
chain <- matrix(0, nrow=n.iter, ncol=2, dimnames=list(NULL,c("pi","N")))
accept <- vector("numeric", n.iter)
chain[1, 1:2] <- theta.0
accept[1] <- 1
N.curr <- N.0
pi.curr <- pi.0
oldlik <- N.law(N.curr, pi.curr, c1, c20)
for (i in 2:n.iter){
#on tire dans la loi conditionnelle complète de pi
#loi uniforme discrète
N.cand <- rdunif(1,N.curr-k,N.curr+k)
u <- runif(n=1,min=0,max=1)
pi.curr <- rbeta(n=1, shape1=c1+c2+a, shape2=2*N.curr-c1-c2+b)
lik <- N.law(N.cand, pi.curr, c1, c20)
r <- lik/oldlik
if (u<min(c(1,r),na.rm = TRUE))
{
N.curr <- N.cand
oldlik <- lik
accept[i] <- 1
}
else {
accept[i]<-0
oldlik<-lik
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)*100))
}
MCMC(c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=900),c(C1=125, C20=134, C21=21),10000,1,3,3)
library(extraDistr)
MCMC <- function(theta.0, y, n.iter, a, b, k){
c1 <- y[1]
c20 <- y[2]
c21 <- y[3]
c2 <- c20 + c21
pi.0 <- theta.0[1]
N.0 <- theta.0[2]
chain <- matrix(0, nrow=n.iter, ncol=2, dimnames=list(NULL,c("pi","N")))
accept <- vector("numeric", n.iter)
chain[1, 1:2] <- theta.0
accept[1] <- 1
N.curr <- N.0
pi.curr <- pi.0
oldlik <- N.law(N.curr, pi.curr, c1, c20)
for (i in 2:n.iter){
#on tire dans la loi conditionnelle complète de pi
#loi uniforme discrète
N.cand <- rdunif(1,N.curr-k,N.curr+k)
u <- runif(n=1,min=0,max=1)
pi.curr <- rbeta(n=1, shape1=c1+c2+a, shape2=2*N.curr-c1-c2+b)
lik <- N.law(N.cand, pi.curr, c1, c20)
r <- lik/oldlik
if (u<min(c(1,r),na.rm = TRUE))
{
N.curr <- N.cand
oldlik <- lik
accept[i] <- 1
}
else {
accept[i]<-0
oldlik<-lik
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)*100))
}
MCMC(c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000),c(C1=125, C20=134, C21=21),10000,1,3,3)
library(extraDistr)
MCMC <- function(theta.0, y, n.iter, a, b, k){
c1 <- y[1]
c20 <- y[2]
c21 <- y[3]
c2 <- c20 + c21
pi.0 <- theta.0[1]
N.0 <- theta.0[2]
chain <- matrix(0, nrow=n.iter, ncol=2, dimnames=list(NULL,c("pi","N")))
accept <- vector("numeric", n.iter)
chain[1, 1:2] <- theta.0
accept[1] <- 1
N.curr <- N.0
pi.curr <- pi.0
oldlik <- N.law(N.curr, pi.curr, c1, c20)
for (i in 2:n.iter){
#on tire dans la loi conditionnelle complète de pi
#loi uniforme discrète
N.cand <- rdunif(1,N.curr-k,N.curr+k)
u <- runif(n=1,min=0,max=1)
pi.curr <- rbeta(n=1, shape1=c1+c2+a, shape2=2*N.curr-c1-c2+b)
lik <- N.law(N.cand, pi.curr, c1, c20)
r <- lik/oldlik
if (u<min(c(1,r),na.rm = TRUE))
{
N.curr <- N.cand
oldlik <- lik
accept[i] <- 1
}
else {
accept[i]<-0
oldlik<-lik
}
chain[i,] <- c(pi.curr, N.curr)
}
return(list(chain=chain, taux.accept=mean(accept)*100))
}
MCMC(c(pi.0=rbeta(n=1, shape1=a, shape2=b), N.0=1000),c(C1=125, C20=134, C21=21),10000,1,3,1)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
cumprod(1:8)
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
cumprod(1:8)[-1]
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
cumprod(1:8)[-1]
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
cumprod(1:8)[1]
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
cumprod(1:8)[-8]
N.law <- function(N, pi, c1, c20){
density <- choose(N,c1+c20)*(1-pi)^(2*N)
return(density)
}
cumprod(1:8)[8]
N.law <- function(N, pi, c1, c20){
density <- cumprod(N-c1-c20+1:N)[c1+c20]*(1-pi)^(2*N)
return(density)
}
N.law <- function(N, pi, c1, c20){
density <- cumprod(N-c1-c20+1:N)[c1+c20]*(1-pi)^(2*N)
return(density)
}
N.law(1000,0.15,125,134)
N.law <- function(N, pi, c1, c20){
density <- cumprod(N-c1-c20+1:N)[c1+c20]*(1-pi)^(2*N)
return(density)
}
N.law(1000,0.15,125,134)/N.law(1000,0.13,125,134)
N.law <- function(N, pi, c1, c20){
density <- cumprod(N-c1-c20+1:N)[c1+c20]*(1-pi)^(2*N)
return(density)
}
N.law(1000,0.15,125,134)/N.law(1000,0.10,125,134)
N.law <- function(N, pi, c1, c20){
density <- cumprod(N-c1-c20+1:N)[c1+c20]*(1-pi)^(2*N)
return(density)
}
double(N.law(1000,0.15,125,134)/N.law(1000,0.10,125,134))
N.law <- function(N, pi, c1, c20){
density <- cumprod(N-c1-c20+1:N)[c1+c20]*(1-pi)^(2*N)
print(density)
return(density)
}
N.law(1000,0.15,125,134)
N.law <- function(N, pi, c1, c20){
density <- cumprod(N-c1-c20+1:N)[c1+c20]*(1-pi)^(2*N)
return(density)
}
N.law(1000,0.15,125,134)
N.law <- function(N, pi, c1, c20){
density <- cumprod(N-c1-c20+1:N)[c1+c20]*(1-pi)^(2*N)
return(density)
}
dim(N.law(1000,0.15,125,134))
N.law <- function(N, pi, c1, c20){
density <- cumprod(N-c1-c20+1:N)[c1+c20]*(1-pi)^(2*N)
return(density)
}
length(N.law(1000,0.15,125,134))
